{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Riptide documentation","text":"<p>Checklists</p><p>Time-saving checklists are always welcome</p> <p>Ros2Control</p><p>To speak about realtime control or the Riptide</p> <p>Simulator</p> <p>Prepare and simulate Riptide's missions</p> <p>Raspberry Pi 4 Image</p> <p>Get the last image to flash on the Riptide</p>"},{"location":"checklists/","title":"Checklists","text":"<p>Here are some checklists available to prepare a mission with peace of mind.</p> <p>H-24</p><p>Checklist to prepare for the day before the mission.</p> <p>H-4</p><p>Checklist to don't forget anything while packing stuff for the mission.</p> <p>H-1</p><p>Checklist to check everything is working on the robot after unpacking stuff.</p> <p>Toolbox</p><p>Checklist for toolbox to always have with the robot.</p>"},{"location":"checklists/mission_checklist/","title":"Mission Checklist","text":""},{"location":"checklists/mission_checklist/#sensors-calibration","title":"Sensors calibration","text":"<ul> <li> Checking pressure zero</li> <li> Checking imu calibration</li> </ul> Fast sensor's status checking <p>To quickly check robot's sensors state, you could use the ncurses interfaces on the robot by typing in a terminal</p> <pre><code>&gt; wtf\n</code></pre> <p>or</p> <pre><code>&gt; ros2 run riptide_wtf riptide_wtf\n</code></pre>"},{"location":"checklists/mission_checklist/#actuators-calibration","title":"Actuators calibration","text":"<ul> <li> Checking fins zeros</li> <li> Checking actuators with RC controller</li> </ul>"},{"location":"checklists/preparation_checklist/","title":"Preparation checklist","text":"<p>Here is the required tasks to do a few hours before the mission.</p>"},{"location":"checklists/preparation_checklist/#batteries-charging","title":"Batteries charging","text":"<ul> <li> Charging Riptide's batteries</li> <li> Charging RC remote batteries</li> <li> Charging flat batteries</li> </ul>"},{"location":"checklists/preparation_checklist/#support-stuff","title":"Support stuff","text":"<ul> <li> Charging PC / ToughBook batteries and spare batteries</li> <li> Charging nitecore battery</li> </ul>"},{"location":"checklists/preparation_checklist/#support-boat-stuff","title":"Support boat stuff","text":"<ul> <li> Charging the boat battery</li> </ul>"},{"location":"checklists/preparation_checklist/#video-stuff","title":"Video stuff","text":"<ul> <li> Charging camera batteries</li> <li> Charging GoPro batteries </li> <li> Charging drone batteries</li> <li> Emptying memory cards</li> <li> Taking extra SD / micro SD cards</li> </ul>"},{"location":"checklists/stuff_checklist/","title":"Stuff checklist","text":"<p>Here is the required stuff checklist to consult while preparing a mission.</p>"},{"location":"checklists/stuff_checklist/#riptide-stuff","title":"Riptide stuff","text":"<ul> <li> Riptide head (with spare)</li> <li> Riptide tail (with spare)</li> <li> Riptide tube (with spare)</li> <li> Riptide battery (with spare)</li> <li> Riptide RC remote (with spare and batteries)</li> <li> Ubiquity (with spare)</li> <li> Flat battery (with spare)</li> </ul>"},{"location":"checklists/stuff_checklist/#support-stuff","title":"Support stuff","text":"<ul> <li> PC / ToughBook (with charger and spare batteries)</li> <li> Table and stools</li> <li> Nitecore battery</li> <li> PC tents</li> <li> Watertight bags</li> <li> Sunscreen cream</li> </ul>"},{"location":"checklists/stuff_checklist/#support-boat-stuff","title":"Support boat stuff","text":"<ul> <li> Life jackets</li> <li> Inflatable black boat with oars and inflation pump, motor and battery</li> <li> Zodiac boat</li> </ul>"},{"location":"checklists/stuff_checklist/#video-stuff","title":"Video stuff","text":"<ul> <li> Cameras with batteries and waterproof cases</li> <li> Tripods</li> <li> GoPro with waterproof cases, batteries, and accessories (tripods, mountings, harness, head mounting, ...)</li> <li> Drones</li> </ul>"},{"location":"checklists/toolbox/","title":"Toolbox","text":""},{"location":"checklists/toolbox/#charging-box","title":"Charging box","text":"<ul> <li> Battery Checkers</li> <li> XT60 Male to banana plug</li> <li> XT90 Male to banana plug</li> <li> JST extension cables for 2S / 3S / 4S</li> <li> Multi charging plug to banana plug</li> </ul>"},{"location":"checklists/toolbox/#sensors-box","title":"Sensor's box","text":"<ul> <li> Sparton AHRS M1</li> <li> BlueRobotics ESC for T200</li> <li> BlueRobotics Bar30 pressure sensor</li> <li> TeamBlackSheep nano receiver</li> <li> Echosounder processing card</li> </ul>"},{"location":"checklists/toolbox/#cable-box","title":"Cable box","text":"<ul> <li> USB FTDI 5V</li> <li> USB FTDI 3V</li> <li> USB type A extension cable</li> <li> USB mini B to USB type A cable</li> <li> USB micro B to USB type A cable</li> <li> USB type C to USB type A cable</li> </ul>"},{"location":"checklists/toolbox/#nuts-and-bolts-box","title":"Nuts and Bolts box","text":"<ul> <li> M3 nuts and bolts</li> <li> M4 nuts and bolts</li> </ul>"},{"location":"design/conventions/","title":"Units Conventions","text":""},{"location":"design/conventions/#units-of-measure-and-coordinate-conventions","title":"Units of measure and coordinate conventions","text":"<p>Riptide units of measure and coordinate convetions are following REP-103: Standard Units of Measure and Coordinate Conventions.</p>"},{"location":"design/imu/","title":"IMU","text":"<p>Riptide imu follows the REP-145: Conventions for IMU Sensor Drivers. IMU associated frame is in NED convention (x-North, y-East, z-Down). </p>"},{"location":"design/imu/#published-topics","title":"Published topics","text":"Topic name Type <code>~/imu/data_raw</code> <code>sensor_msgs/Imu</code> <code>~/imu/data</code> <code>sensor_msgs/Imu</code> <code>~/imu/mag</code> <code>sensor_msgs/MagneticField</code>"},{"location":"design/imu/#calibration","title":"Calibration","text":""},{"location":"design/network/","title":"Network","text":""},{"location":"design/network/#riptide-access-point","title":"Riptide access point","text":"<p>The Riptide is providing an wifi access point mainly to communicate with the Raspberry Pi at lab or during mission preparation. This access point is generally unavailable when the Riptide is at the sea surface due to attenuation of radio signals by water.</p> ssid Password <code>Riptide1</code> <code>Riptide1</code> Ip Adress Device <code>192.168.0.100/24</code> Computer <code>192.168.0.101/24</code> Riptide"},{"location":"design/network/#tail-network-card","title":"Tail network card","text":"<p>The <code>d_fin</code> of the Riptide is instrumented with a Wifi device. In this way, the Riptide is reachable at the sea surface through this internet interface.</p> <p>This interface is configured to be connected to the network <code>RiptideNet</code> typically provided by an Ubiquity Bullet setup in the trial area.</p> ssid Password <code>RiptideNet</code> <code>RiptideNet</code> Ip Adress Device <code>192.168.1.100/24</code> Computer <code>192.168.1.101/24</code> Riptide <code>192.168.1.11/24</code> TBSCrossfire"},{"location":"design/network/#ip-forwarding","title":"Ip Forwarding","text":"<p>To provide internet access to the Riptide, the following script is usefull. It let Riptide access internet through is wifi interface (wifi access point or tail interface) using the computer's internet access. The Riptide is configured witha a gateway at <code>192.168.0.100</code> or <code>192.168.1.100</code> depending on the internet device in use. It should then be launched on the computer with internet access on this ip address. </p> <pre><code>_available_interfaces() {\nlocal cmd\n    if [ \"${1:-}\" = -w ]; then\ncmd=\"iwconfig\"\nelif [ \"${1:-}\" = -a ]; then\ncmd=\"ifconfig\"\nelse\ncmd=\"ifconfig -a\"\nfi\nCOMPREPLY=( $( eval $cmd 2&gt;/dev/null | sed -ne 's|^\\('$cur'[^[:space:][:punct:]]\\{1,\\}\\).*$|\\1|p'))\n}\n\ncomplete -F _available_interfaces ip-forwarding\n\n# NAT\nip-forwarding() {\nsudo sysctl -w net.ipv4.ip_forward=1\nsudo /sbin/iptables -F;\nsudo /sbin/iptables -t nat -F;\nsudo /sbin/iptables -X;\nsudo /sbin/iptables -t nat -X;\nsudo /sbin/iptables -t nat -A POSTROUTING -o $1 -j MASQUERADE;\nsudo /sbin/iptables -A FORWARD -i $1 -o $2 -m state --state RELATED,ESTABLISHED -j ACCEPT;\nsudo /sbin/iptables -A FORWARD -i $2 -j ACCEPT;\n}\n</code></pre> <p>To redirect internet flow from <code>wlo1</code> to <code>enx0</code> (if <code>wlo1</code> is connected to the Riptide and <code>enx0</code> is connected to internet) use</p> <pre><code>&gt; ip-forwarding enx0 wlo1\n</code></pre>"},{"location":"design/network/#troubleshooting","title":"Troubleshooting","text":"Is the kernel detecting the internet device ? <p>Check there is no error in <code>dmesg</code> <pre><code>&gt; sudo dmesg\n...\n[ 1668.672012] usb 1-1.1: New USB device found, idVendor=148f, idProduct=5372, bcdDevice= 1.01                                                                                                                     [ 1668.672040] usb 1-1.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3                                                                                                                                 [ 1668.672056] usb 1-1.1: Product: 802.11 n WLAN                                                                                                                                                                   [ 1668.672070] usb 1-1.1: Manufacturer: Ralink                                                                                                                                                                     [ 1668.758037] usb 1-1.1: reset high-speed USB device number 7 using xhci_hcd                            [ 1668.867767] ieee80211 phy2: rt2x00_set_rt: Info - RT chipset 5392, rev 0223 detected                  [ 1668.894218] ieee80211 phy2: rt2x00_set_rf: Info - RF chipset 5372 detected                            [ 1668.894544] ieee80211 phy2: Selected rate control algorithm 'minstrel_ht'                             [ 1668.967671] ieee80211 phy2: rt2x00lib_request_firmware: Info - Loading firmware file 'rt2870.bin'                                                                                                               [ 1668.969027] ieee80211 phy2: rt2x00lib_request_firmware: Info - Firmware detected - version: 0.36                                                                                                                [ 1669.233122] ieee80211 phy2: rt2x00usb_vendor_request: Error - Vendor Request 0x07 failed for offset 0x0500 with error -71                                                  [ 1669.257012] usb 1-1.1: USB disconnect, device number 7                                                                                                                                                          [ 1669.257327] ieee80211 phy2: rt2x00usb_vendor_request: Error - Vendor Request 0x06 failed for offset 0x0500 with error -19                                               [ 1669.785094] usb 1-1.1: new full-speed USB device number 8 using xhci_hcd                                                                                                                                        [ 1669.865333] usb 1-1.1: device descriptor read/64, error -32\n...\n</code></pre></p> <p>It very common to have corroded usb extension cable causing communication problems with wifi interface (No joke, trust me ). A life-saving product in this case is Contact Cleaner, a spray on the plug and everything should be working again.</p> <p>To avoid this corrosion problem, only one solution</p> <p>Stop letting water get into the Riptide's body buddy!</p> Is there a driver error ? <p>The driver is not always installed by default on the Raspberry Pi and depend on the Linux Kernel version which is regularly updated.</p> <p>To install the drivers corresponding to the current Linux Kernel version run:</p> <pre><code>&gt; sudo apt install linux-modules-extra-$(uname -r)\n</code></pre> <p>There is also this upgrade-friendly command</p> <pre><code>&gt; sudo apt install linux-generic\n</code></pre> <p>Note about the latter command</p> <p>It works for now, and it seems to do the same thing as the previous command! Let see if it surive a Kernel upgrade ...</p> Is the internet device available ? <p>To see if the internet device is available run</p> <pre><code>&gt; nmcli\nwlan0: connected to Riptide1                        \"Broadcom BCM43438 combo and Bluetooth Low Energy\"                                               wifi (brcmfmac), E4:5F:01:5D:F5:94, hw, mtu 1500                                                 ip4 default                                 inet4 192.168.0.101/24                      route4 192.168.0.0/24 metric 600            route4 default via 192.168.0.100 metric 600                                                      \n\nwlan1: connected to RiptideNet                      \"Ralink RT5372\"                             wifi (rt2800usb), 9C:EF:D5:FD:B0:BC, hw, mtu 1500                                                inet4 192.168.1.101/24                      route4 192.168.1.0/24 metric 601            route4 default via 192.168.1.100 metric 601                                                      inet6 fe80::ac66:5086:1c1a:a60b/64          route6 fe80::/64 metric 1024\n...\n</code></pre> <p>Here the <code>wlan1</code> is available and connected to RiptideNet. If not, there is probably a driver error, a cable issue or maybe too much water inside the Riptide ...  </p>"},{"location":"design/transforms/","title":"Transforms","text":""},{"location":"design/transforms/#riptide-transforms","title":"Riptide Transforms","text":"<p>TF is the Riptide are following the REP-105: Coordinate Frames for Mobile Platforms.</p> <pre><code>flowchart LR\n    subgraph world\n    direction LR\n    w1(earth)--&gt;w2(map)--&gt;w3(odom)--&gt;w4(base_link)\n    end\n    subgraph actuators\n    direction LR\n    w4--&gt;thruster &amp; d_fin &amp; p_fin &amp; s_fin\n    end\n    subgraph sensors\n    direction LR\n    w4--&gt; imu_ned &amp; pressure &amp; echsounder\n    end</code></pre>"},{"location":"packages/packages_list/","title":"Packages list","text":"<p>Here is the list of packages implemented for the Riptide. Implemented packages are available on the  Riptide-Team GitHub Organization.</p> Package name Description <code>riptide_hardware</code> Riptide hardware interfaces <code>riptide_controllers</code> Riptide controllers <code>riptide_msgs</code> Riptide messages <code>riptide_navigation</code> Riptide mission scripts <code>riptide_bringup</code> Riptide launchfiles <code>riptide_description</code> Riptide urdf description <code>riptide_bringup_sim</code> Riptide simulation launchfiles <code>riptide_description</code> Riptide simulation urdf description"},{"location":"quickstart/simulator/","title":"Simulator","text":"<p>The simulator is based on Ignition Gazebo Garden. It let to quickly test the behavior of the Riptide while implementing new control laws. Riptide simulation and worlds are described using SDFormat language.</p> <p></p>"},{"location":"quickstart/simulator/#available-worlds","title":"Available worlds","text":""},{"location":"quickstart/simulator/#infinite-ocean","title":"Infinite ocean","text":"<p>The riptide is currently launched in an infinite ocean. The sea-surface is fixed at \\(z = 0\\ m\\), above the fluid density is fixed at \\(\\rho_{air} = 1\\ kg.m^{-3}\\) and below this limit the density is fixed at \\(\\rho_{air} = 1000\\ kg.m^{-3}\\).</p> Actuators and sea surface <p>Actuators are for now configured to generate forces and momentums with a constant fluid density (i.e. the graded fluid density is not taken into account for force generation).</p> <p>It means that actuators are able to move the Riptide in air as well as in water, except that in air the buoyancy is well computed so the robot need more forces and momentums to be moved.</p>"},{"location":"quickstart/taranis_qx7/","title":"Taranis QX7 Controller","text":""},{"location":"quickstart/taranis_qx7/#switch-layout","title":"Switch Layout","text":"<p>Here is the switch layout of the <code>FrSky Taranis Q X7</code> controller.</p> <p></p> <p>Control are currently bind respecting the following table:</p> Input Command Description <code>J1</code> Rudder (RUD / Yaw) Yaw of the robot <code>J2</code> Elevator (ELE / Pitch) Pitch of the robot <code>J3</code> Aileron (AIL / Roll) Roll (not bind for now) <code>J4</code> Thrust Thrust value of the propeller <code>SA</code> Forward / Neutral / Backward Sign of the thrust <code>SF</code> Automatic / Manual Enable the controller <code>SH</code> Multiplexer ignition Latching the switch launch the multiplexer <code>SD</code> Multiplexer multiplicator Multiplication factor: \\(\\times 1\\) / \\(\\times 2\\) / \\(\\times 3\\) <code>S1</code> Multiplexer value Value of the time allowed for the mission"},{"location":"quickstart/taranis_qx7/#modded-taranis-for-tbs-crossfire-telemetry","title":"Modded Taranis for TBS Crossfire Telemetry","text":"<p>The FrSky Taranis Q X7 controller has been modded to have a reliable telemetry. Without this modification the telemetry seems to be lost and recovered approximatively every seconds. Furthermore, this modification allow to increase the baudrate from \\(100 kHz\\) to \\(400 kHz\\) for the radio communication.</p> <p>This modification is simply a solder of the micro-pcb sold with the TBS Crossfire TX instead of an original Frky Taranis Q X7 transistor, which has to be removed. The procedure is available on the Philipp Seidel's blog. The installation is quite easy but requires some good soldering skills .</p> <p> </p> Modded FrSky Taranis Q X7 Controller"},{"location":"quickstart/taranis_qx7/#simulation","title":"Simulation","text":"<p>Here is the procedure to use the <code>FrSky Taranis Q X7</code> controller with the simulator.</p> <ul> <li>Put a battery in the <code>FrSky Taranis Q X7</code></li> <li>Start the <code>FrSky Taranis Q X7</code></li> <li>Plug an usb cable in the bottom usb port of the <code>FrSky Taranis Q X7</code></li> <li>Plug this cabe in an usb port of the computer</li> <li>Select mode <code>USB Joystick (HID)</code> on the <code>FrSky Taranis Q X7</code></li> <li>Check that the device is recognized by the computer and accessible by <code>Ros2</code></li> <li>Launch the <code>joy_node</code> of the <code>joy</code> package</li> </ul> <pre><code>&gt; ros2 run joy joy_node\n[INFO 1693900564.881254763] [joy_node]: No haptic (rumble) available, skipping initialization (handleJoyDeviceAdded() at ./src/joy.cpp:394)                                                                 [INFO 1693900564.881379413] [joy_node]: Opened joystick: OpenTX FrSky Taranis Joystick.  deadzone: 0.0 50000 (handleJoyDeviceAdded() at ./src/joy.cpp:397)\n</code></pre> <p><code>sensor_msgs/msg/Joy</code> should be published by the <code>joy_node</code> under the <code>/joy</code> topic.</p>"},{"location":"quickstart/taranis_qx7/#troubleshooting","title":"Troubleshooting","text":"Is the controller well recognized by the computer ? <p>To check that the <code>Taranis QX7 Controller</code> is well recognized by the computer and <code>Ros2</code> you can run</p> <p><pre><code>&gt; ros2 run joy joy_enumerate_devices\nJoystick Device ID : Joystick Device Name\n-----------------------------------------\n                0 : OpenTX FrSky Taranis Joystick\n</code></pre> Here the controller is well recognized.</p> How to check that messages are correctly published ? <p>You can check that the <code>/joy</code> topic is welle created by the <code>joy_node</code></p> <pre><code>&gt; ros2 topic list\n/joy\n/joy/set_feedback\n/parameter_events\n/rosout\n</code></pre> <p>And then check published messages and control that messages are changing relative to controller's input</p> <pre><code>&gt; ros2 topic echo /joy\nheader:\nstamp:\n    sec: 1693900834\nnanosec: 880572482\nframe_id: joy\naxes:\n- 1.0\n- 1.0\n- -0.0\n- -0.0\n- -0.0\n- -0.0\n- -0.0\nbuttons:\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n- 0\n---\n</code></pre> Can I unplug the TBS Crossfire RC emitter from the Controller ? <p>Yes indeed ! It's safer to avoid unwanted control of the Riptide through simulation and to avoid emitter's buzzing noise while trying to communicate with the RC receiver in the Riptide.</p>"},{"location":"ros2control/","title":"Ros2Control","text":"<p>Ros2Control is a framework providing interesting features in robotics, such as realtime control. This page is presenting the main features that are usefull in the Riptide control.</p>"},{"location":"ros2control/#realtime-control","title":"Realtime control","text":"<p>Ros2Control is able to efficiently read sensors data, and ask the controller to create a command to be applied on actuators in realtime (i.e. in the same loop). No outdated sensor data will be used by the controller.</p> Realtime kernel <p>Use a realtime kernel to benefit of the realtime aspect of Ros2Control.</p>"},{"location":"ros2control/#sensors-actuators-failure-detection","title":"Sensors / actuators failure detection","text":"<p>Hardware interfaces always return success or failure at each step. The detection of a failure is then immediate and a strategy could be adopted depending on the encountered fail.</p> Failure detection strategy <p>Failure detection is already implemented for sensor and actuators interfaces, but there is not yet any strategies in such cases.</p>"},{"location":"ros2control/#actuators-control-interface-claimable-once","title":"Actuators control interface claimable once","text":"<p>It's recommanded to avoid multiple nodes to control the same actuator at the same time, which is possible when using classical Ros2 topics to conrtol an actuator. Using Ros2Control framework prevents this behavior.</p>"},{"location":"ros2control/#efficient-switch-of-controllers","title":"Efficient switch of controllers","text":"<p>Controllers can be switched runtime between two control loops to avoid downtimes. It's better than classical solution provided by ros which cannot perform such tasks.</p>"},{"location":"ros2control/#chaining-controllers","title":"Chaining controllers","text":"<p>Controllers can be chained to elaborate more complex control laws based on atomic controlkers.</p> Available controllers <p>Consult the list of available controllers </p>"},{"location":"ros2control/#simulation-and-real-code-are-the-same","title":"Simulation and real code are the same","text":"<p>Hardware interfaces can be transparently switched as soon as they are providing the same <code>command_interface</code> and <code>state_interface</code>. Simulation specific <code>hardware_interfaces</code> can be implemented to interact with the simulator instead sensors and actuators.</p> Simulator <p>See the simulator section to know how to simulate the Riptide.</p>"},{"location":"ros2control/#design","title":"Design","text":"<p>Hardware interfaces should be implemented to communicate with sensors and actuators and provide <code>command_interface</code> and <code>state_interface</code>.</p> <p>Controllers are also implemented which are claiming these <code>command_interface</code> and <code>state_interface</code> to compute the command to be applied on actuators following custom or classical control theory.</p>"},{"location":"ros2control/broadcasters/","title":"Available broadcasters","text":"<p>Here is the list of implemented broadcasters for the Riptide</p> Controller name Type Description <code>joint_state_broadcaster</code> <code>Controller</code> Broadcast joint states <code>imu_sensor_broadcaster</code> <code>Controller</code> Broadcast imu sensor's data <code>riptide_pressure_broadcaster</code> <code>Controller</code> Broadcast pressure data <code>riptide_tail_broadcaster</code> <code>Controller</code> Broadcast tail data"},{"location":"ros2control/broadcasters/imu_sensor_broadcaster/","title":"Imu sensor broadcaster","text":"<p>Controller implementation</p> <p>This broadcaster is natively implemented in the package <code>ros2_controllers</code> of <code>Ros2Control</code>. The documentation of this broadcaster is available here</p>"},{"location":"ros2control/broadcasters/joint_state_broadcaster/","title":"Joint state broadcaster","text":"<p>Controller implementation</p> <p>This broadcaster is natively implemented in the package <code>ros2_controllers</code> of <code>Ros2Control</code>. The documentation of this broadcaster is available here</p>"},{"location":"ros2control/broadcasters/riptide_pressure_broadcaster/","title":"Riptide pressure broadcaster","text":""},{"location":"ros2control/broadcasters/riptide_pressure_broadcaster/#state-interfaces","title":"State interfaces","text":"<p>-</p>"},{"location":"ros2control/broadcasters/riptide_pressure_broadcaster/#parameters","title":"Parameters","text":"<p>-</p>"},{"location":"ros2control/broadcasters/riptide_tail_broadcaster/","title":"Riptide tail broadcaster","text":""},{"location":"ros2control/broadcasters/riptide_tail_broadcaster/#state-interfaces","title":"State interfaces","text":"<p>-</p>"},{"location":"ros2control/broadcasters/riptide_tail_broadcaster/#parameters","title":"Parameters","text":"<p>-</p>"},{"location":"ros2control/controllers/","title":"Ros2Control controllers","text":""},{"location":"ros2control/controllers/#list-of-controllers","title":"List of controllers","text":"<p>Here is the list of implemented controllers for the Riptide</p> Controller name Type Description <code>immersion_controller</code> <code>Controller</code> Riptide immersion controller <code>riptide_controller</code> <code>ChainableController</code> Riptide twist controller <code>log_controller</code> <code>ChainableController</code> Log based atitude controller <code>depth_controller</code> <code>Controller</code> Simple depth controller <code>orthogonal_controller</code> <code>Controller</code> Orthogonal based atitude controller <code>repartition_controller</code> <code>Controller</code> Wrench repartition controller"},{"location":"ros2control/controllers/#typical-use","title":"Typical use","text":"<p>Here is the typical use of chained controllers.</p> <pre><code>flowchart LR\n    c1(immersion_controller) -- commands --&gt; r(riptide)\n    class c1,c2,c3 controller;\n    class r riptide;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef riptide stroke:#e74c3c,stroke-width:2px;</code></pre> <pre><code>flowchart LR\n    c3(depth_controller) -- desired_orientation --&gt; c2(log_controller) -- angular velocity --&gt; c1(riptide_controller) -- commands --&gt; r(riptide)\n    class c1,c2,c3 controller;\n    class r riptide;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef riptide stroke:#e74c3c,stroke-width:2px;</code></pre>"},{"location":"ros2control/controllers/depth_controller/","title":"Depth controller","text":"<p>Depth controller able to control depth of the Riptide by controlling the robot's pitch.</p> <pre><code>flowchart LR\n    s1[depth] &amp; s2[orientation.x] &amp; s3[orientation.y] &amp; s4[orientation.z] &amp; s5[orientation.w] --- S( ):::empty --&gt; c(depth_controller) --- R( ):::empty --&gt; c1[orientation.x] &amp; c2[orientation.y] &amp; c3[orientation.z] &amp; c4[orientation.w]\n    class s1,s2,s3,s4,s5 state;\n    class c1,c2,c3,c4 command;\n    class c controller;\n    classDef state stroke:#2ecc71,stroke-width:2px;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/depth_controller/#command-interfaces","title":"Command interfaces","text":"<code>command_interface</code> Description <code>orientation.x</code> Desired orientation quaternion x <code>orientation.y</code> Desired orientation quaternion y <code>orientation.z</code> Desired orientation quaternion z <code>orientation.w</code> Desired orientation quaternion w"},{"location":"ros2control/controllers/depth_controller/#state-interfaces","title":"State interfaces","text":"<code>state_interface</code> Description <code>depth</code> Riptide depth <code>orientation.x</code> Robot orientation quaternion x <code>orientation.y</code> Robot orientation quaternion y <code>orientation.z</code> Robot orientation quaternion z <code>orientation.w</code> Robot orientation quaternion w"},{"location":"ros2control/controllers/depth_controller/#published-topics","title":"Published topics","text":"Topic name Type Description <code>~/controller_state</code> <code>riptide_msgs/RiptideControllerState</code> Controller actual state"},{"location":"ros2control/controllers/depth_controller/#provided-action","title":"Provided action","text":"Action name Type Description <code>~/depth</code> <code>riptide_msgs/Depth</code> Controller desired depth"},{"location":"ros2control/controllers/immersion_controller/","title":"Immersion controller","text":"<p>Open loop immersion controller able to immerse the Riptide 1m below the sea surface. The strategy is to set the thruster's velocity at its maximum, and to perform a maneuver on the fins such as the Riptide's pitch increase and then decrease suddenly.</p> <pre><code>flowchart LR\n    c(immersion_controller) --- C( ):::empty --&gt;c1[thruster] &amp; c2[d_fin] &amp; c3[p_fin] &amp; c4[s_fin]\n    class s1,s2,s3,s4 state;\n    class c1,c2,c3,c4 command;\n    class c controller;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/immersion_controller/#command-interfaces","title":"Command Interfaces","text":"<code>command_interface</code> Description <code>thruster</code> Thruster velocity <code>p_fin</code> Direction-fin angle <code>p_fin</code> Port-fin angle <code>s_fin</code> Starboard-fin angle"},{"location":"ros2control/controllers/immersion_controller/#provided-action","title":"Provided action","text":"Action name Type Description <code>~/immerse</code> <code>riptide_msgs/Immerse</code> Controller immerse order"},{"location":"ros2control/controllers/log_controller/","title":"Log Controller","text":"<p>Log controller able to generate angular velocity from current robot's orientation and desired orientation.</p> <pre><code>flowchart LR\n    s1[orientation.x] &amp; s2[orientation.y] &amp; s3[orientation.z] &amp; s4[orientation.w] &amp; r1[desired_orientation.x] &amp; r2[desired_orientation.y] &amp; r3[desired_orientation.z] &amp; r4[desired_orientation.w] --- s( ):::empty --&gt; c(log_controller) --- R( ):::empty --&gt; c1[linear_velocity.x] &amp; c2[angular_velocity.x] &amp; c3[angular_velocity.y] &amp; c4[angular_velocity.z]\n    class s1,s2,s3,s4 state;\n    class c1,c2,c3,c4 command;\n    class r1,r2,r3,r4 reference;\n    class c controller;\n    classDef state stroke:#2ecc71,stroke-width:2px;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef reference stroke:#8e44ad,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/log_controller/#command-interfaces","title":"Command interfaces","text":"<code>command_interface</code> Description <code>linear_velocity.x</code> Requested linear velocity along x axis <code>angular_velocity.x</code> Requested angular velocity along x axis <code>angular_velocity.y</code> Requested angular velocity along y axis <code>angular_velocity.z</code> Requested angular velocity along z axis"},{"location":"ros2control/controllers/log_controller/#state-interfaces","title":"State interfaces","text":"<code>state_interface</code> Description <code>orientation.x</code> Robot orientation quaternion x <code>orientation.y</code> Robot orientation quaternion y <code>orientation.z</code> Robot orientation quaternion z <code>orientation.w</code> Robot orientation quaternion w"},{"location":"ros2control/controllers/log_controller/#reference-interfaces","title":"Reference interfaces","text":"<code>reference_interface</code> Description <code>desired_orientation.x</code> Desired orientation quaternion x <code>desired_orientation.y</code> Desired orientation quaternion y <code>desired_orientation.z</code> Desired orientation quaternion z <code>desired_orientation.w</code> Desired orientation quaternion w"},{"location":"ros2control/controllers/log_controller/#subscribed-topic","title":"Subscribed topic","text":"Topic name Type Description <code>~/desired_quaternion</code> <code>geometry_msgs/Quaternion</code> Desired orientation quaternion"},{"location":"ros2control/controllers/log_controller/#published-topics","title":"Published topics","text":"Topic name Type Description <code>~/controller_state</code> <code>riptide_msgs/LogControllerState</code> Controller actual state"},{"location":"ros2control/controllers/orthogonal_controller/","title":"Orthogonal controller","text":"<p>Orthogonal controller able to control the Riptide in such a way that it makes vectors expressed in the robot frame orthogonal to vectors in the world frame.</p> <p>This controller is related to the log_controller in the way that it generate angular velocity for the Riptide, but, unlike the latter, it allows you to control only part of the robot's orientation. This lead to fastest reorientations, and the possibility to control uncontrolled degrees of freedom using other controllers.</p> <pre><code>flowchart LR\n    r1[additionnal_angular_velocity.x] &amp; r2[additionnal_angular_velocity.y] &amp; r3[additionnal_angular_velocity.z] --- S( ):::empty --&gt; c(orthogonal_controller) --- R( ):::empty --&gt; c1[linear_velocity.x] &amp; c2[angular_velocity.x] &amp; c3[angular_velocity.y] &amp; c4[angular_velocity.z]\n    class c1,c2,c3,c4 command;\n    class r1,r2,r3 reference;\n    class c controller;\n    classDef state stroke:#2ecc71,stroke-width:2px;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef reference stroke:#8e44ad,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/orthogonal_controller/#command-interfaces","title":"Command Interfaces","text":"<code>command_interface</code> Description <code>linear_velocity.x</code> Requested linear velocity along x axis <code>angular_velocity.x</code> Requested angular velocity along x axis <code>angular_velocity.y</code> Requested angular velocity along y axis <code>angular_velocity.z</code> Requested angular velocity along z axis"},{"location":"ros2control/controllers/orthogonal_controller/#state-interfaces","title":"State Interfaces","text":"<p>-</p>"},{"location":"ros2control/controllers/orthogonal_controller/#reference-interfaces","title":"Reference Interfaces","text":"<code>reference_interface</code> Description <code>additional_angular_velocity.x</code> Additionnal angular velocity along x axis <code>additional_angular_velocity.y</code> Additionnal angular velocity along y axis <code>additional_angular_velocity.z</code> Additionnal angular velocity along z axis"},{"location":"ros2control/controllers/repartition_controller/","title":"Repartition Controller","text":"<p>Riptide forces and torques repartition controller able to generate thruster and fin control values from desired Wrench.</p> <pre><code>flowchart LR\n    s1[force.x] &amp; s2[torque.x] &amp; s3[torque.y] &amp; s4[torque.z] --- S( ):::empty --&gt; c(repartition_controller) --- R( ):::empty --&gt; c1[thruster] &amp; c2[d_fin] &amp; c3[p_fin] &amp; c4[s_fin]\n    class s1,s2,s3,s4 state;\n    class c1,c2,c3,c4 command;\n    class c controller;\n    classDef state stroke:#2ecc71,stroke-width:2px;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/repartition_controller/#command-interfaces","title":"Command interfaces","text":"<code>command_interface</code> Description <code>thruster</code> Thruster velocity <code>d_fin</code> Direction-fin angle <code>p_fin</code> Port-fin angle <code>s_fin</code> Starboard-fin angle"},{"location":"ros2control/controllers/repartition_controller/#state-interfaces","title":"State interfaces","text":"<code>state_interface</code> Description <code>force.x</code> Robot force quaternion x <code>torque.x</code> Robot torque y <code>torque.y</code> Robot torque z <code>torque.z</code> Robot torque w"},{"location":"ros2control/controllers/repartition_controller/#reference-interfaces","title":"Reference interfaces","text":"<code>reference_interface</code> Description <code>force.x</code> Requested force along x axis <code>torque.x</code> Requested torque along x axis <code>torque.y</code> Requested torque along y axis <code>torque.z</code> Requested torque along z axis"},{"location":"ros2control/controllers/repartition_controller/#subscribed-topics","title":"Subscribed topics","text":"Topic name Type Description <code>~/wrench</code> <code>geometry_msgs/Wrench</code> Requested Wrench"},{"location":"ros2control/controllers/repartition_controller/#published-topics","title":"Published topics","text":"Topic name Type Description <code>~/controller_state</code> <code>riptide_msgs/RepartitionControllerState</code> Controller actual state"},{"location":"ros2control/controllers/riptide_controller/","title":"Riptide Controller","text":"<p>Riptide controller able to generate thruster and fin control values from desired linear and angular velocities.</p> <pre><code>graph LR\n    s1[linear_velocity.x] &amp; s2[angular_velocity.x] &amp; s3[angular_velocity.y] &amp; s4[angular_velocity.z] --- S( ):::empty\n    r1[linear_velocity.x] &amp; r2[angular_velocity.x] &amp; r3[angular_velocity.y] &amp; r4[angular_velocity.z] --- S\n    S --&gt; c(riptide_controller) --- C( ):::empty\n    C --&gt; c1[thruster] &amp; c2[d_fin] &amp; c3[p_fin] &amp; c4[s_fin]\n    class s1,s2,s3,s4 state;\n    class c1,c2,c3,c4 command;\n    class r1,r2,r3,r4 reference;\n    class c controller;\n    classDef state stroke:#2ecc71,stroke-width:2px;\n    classDef controller stroke:#3498db,stroke-width:2px;\n    classDef command stroke:#e74c3c,stroke-width:2px;\n    classDef reference stroke:#8e44ad,stroke-width:2px;\n    classDef empty width:-1px,height:-1px;</code></pre>"},{"location":"ros2control/controllers/riptide_controller/#command-interfaces","title":"Command interfaces","text":"<code>command_interface</code> Description <code>thruster</code> Thruster velocity <code>p_fin</code> Direction-fin angle <code>p_fin</code> Port-fin angle <code>s_fin</code> Starboard-fin angle"},{"location":"ros2control/controllers/riptide_controller/#state-interfaces","title":"State interfaces","text":"<code>state_interface</code> Description <code>orientation.x</code> Robot orientation quaternion x <code>orientation.y</code> Robot orientation quaternion y <code>orientation.z</code> Robot orientation quaternion z <code>orientation.w</code> Robot orientation quaternion w"},{"location":"ros2control/controllers/riptide_controller/#reference-interfaces","title":"Reference interfaces","text":"<code>reference_interface</code> Description <code>linear_velocity.x</code> Requested linear velocity along x axis <code>angular_velocity.x</code> Requested angular velocity along x axis <code>angular_velocity.y</code> Requested angular velocity along y axis <code>angular_velocity.z</code> Requested angular velocity along z axis"},{"location":"ros2control/controllers/riptide_controller/#subscribed-topic","title":"Subscribed topic","text":"Topic name Type Description <code>~/cmd_vel</code> <code>geometry_msgs/Twist</code> Desired Twist"},{"location":"ros2control/controllers/riptide_controller/#published-topics","title":"Published topics","text":"Topic name Type Description <code>~/controller_state</code> <code>riptide_msgs/RiptideControllerState</code> Controller actual state"},{"location":"ros2control/hardware_interfaces/","title":"Hardware Interfaces","text":""},{"location":"ros2control/hardware_interfaces/imu_hardware_interface/","title":"Imu Hardware Interface","text":""},{"location":"ros2control/hardware_interfaces/pressure_hardware_interface/","title":"Pressure Hardware Interface","text":""},{"location":"ros2control/hardware_interfaces/tail_hardware_interface/","title":"Tail Hardware Interface","text":""}]}